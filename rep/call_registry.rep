// HASH TABLE amb tècnica open hashing.

/*
template <typename T>
class HashFunct
{
public:
    int operator()(const T &x) const throw();
};


// Especialització del template Hash per T = string:
//Suma no ponderada dels caràcters.

template <>
class HashFunct<string>
{
public:
    int operator()(const string &x) const throw()
    {
        nat n = 0;
        for (nat i = 0; i < x.length(); ++i)
        {
            n = n + x[i] * i; // a n sumen el codi ascii
        }
        return n;
    }
};


// Especialització del template Hash per T = int:
// Bits centrals del quadrat del número multiplicat per PI.

template <>
class HashFunct<int>
{
    static long const MULT = 31415926;

public:
    int operator()(const int &x) const throw()
    {
        long y = ((x * x * MULT) << 20) >> 4;
        return y;
    }
};


template <typename Clau>
static int hash(const Clau &k) throw()
{
    HashFunct<Clau> h;
    return h(k) % _M;
}
*/

/*
template <typename T>
class Hash
{
public:
    int operator()(const T &x) const throw();
};

template <>
class Hash<int>
{
    static long const MULT = 31415926;

public:
    int operator()(const int &x) const throw()
    {
        long y = ((x * x * MULT) << 20) >> 4;
        return y;
    }
};
*/

// TODO: Stills reimaining add constructor of the struct.
template <typename Clau, typename Valor> //, typename HashFunct = Hash
struct node_hash
{
    Clau m_clau;
    Valor *m_valor;
    node_hash *m_seg;
    //HashFunct hash(const Clau &k);
};

node_hash<nat, phone> **m_taula;

nat m_mida;
nat m_quants;

node_hash<string, phone> **m_taula_noms;
nat m_mida_noms;
nat m_quants_noms;

// Calcula la posició en la taula per al número donat.
nat hash(nat num) const;

// Afegeix una nova entrada amb el número, nom i comptador donats.
void afegeix_entrada(const nat &num, const string &nom, nat compt);

// Duplica l'espai de la taula quan s'arriba al llindar de factor de carrega.
void redispersio();

/* 
 Busca en l'estructura l'element amb clau num i assigna els paràmetres hi_es si l'ha trobat
 i un punter al primer node trobat en la llista de nodes i un altre al predecessor (si n'hi ha).
*/
bool obtenir_phone(const nat &num, node_hash<nat, phone> *&p, node_hash<nat, phone> *&pr);

// Constants
const float factor_carrega = 0.75;

const string nom_mod = "call_registry";

const string MsgErrNumeroInexistent = "Numero inexistent.";
const string MsgErrNomRepetit = "Nom repetit.";

// Estadístiques
nat colisions = 0, redispersions = 0;

// AVL

/*
struct node
{
    nat m_clau;
    Phone *m_val;
    node *m_fe;
    node *m_fd;
    nat m_alcada;
};

nat m_total;
node *m_arrel;



    A priori hem analitzat que el diccionari amb les propietats de BST i AVL són les més idonies 
    a les necessitats requerides en els diversos punts que es mencionarán:

    1. No requereix coneixer previament la quantitat d'elements.
    2. Els costos són logaritmics en el cas mitjà.
    3. Ens permet el parell clau-valor on clau és el num de telèfon i clau un punter al objecte phone.
    4. Els costos del constructor per còpia i operador d'assignación són lineals.

    Altres estructures:

    +-----------------------------------------------------------------------+
    | Estructura   |  Cost constructor  |  Cost consultar  |  Cost eliminar |
    +-----------------------------------------------------------------------+
    |  HASH        |       O(n)         |       O(1)        |     O(1)      |
    |  AVL         |       O(1)         |       O(log n)    |     O(log n)  |
    |  Linked list |
    +-----------------------------------------------------------------------+
*/